进程组和会话在进程之间形成了一种两级层次关系：  
进程组是一组相关进程的集合，会话是一组相关进程组的集合。

# 进程组

- 每个进程有个一个进程组id
- 新进程会继承父进程的进程组id
- 进程调用getpgrp系统调用可以获取进程id
- 如果调用getpgrp系统调用返回的进程id和自己的进程id相同，说明当前进程是这个进程组的首进程
- 每个进程组都会有一个首进程
- 首进程和其他进程的结束没有先后顺序
- 系统调用setpgid(pid,pgid) 可以将进程pid的进程组修改为 pgid，可以通过这个系统调用新建进程组

# 会话

- 会话是一个进程组的集合
- 新进程会继承父进程的会话id
- gettsid(pid)系统调用可以 可以返回指定进程的会话id；如果pid为0 ，会返回当前进程的会话id
- 如果gettsid(pid)=pid 说明pid进程为其所在会话的首进程
- 系统调用setsid() 会创建一个新会话；调用进程会成为新会话的首进程和该会话中新进程组的首进程；调用的进程没有控制终端，之前的`控制终端`会被断开
# 控制终端
- 一个会话所有的进程可能只拥有一个控制终端
- 一个终端只能至多成为一个会话的控制终端
- 当一个进程打开一个终端时，这个进程会成为该终端的控制进程
- 如果一个进程拥有控制终端，可以大概特殊的文件描述符 /dev/tty
- 删除进程与控制终端之间的关联或者控制进程终止时，内核会向`前台进程组`的所有成员发送sighup信号通知


# 前台后台进程组
- 一个会话中同一时刻只有一个进程成为前台进程，会话中其他所有进程都是后台进程
- 一个会话可以有多个后台进程组，但只能有一个前台进程组
- 前台进程组是唯一能自由读取和写入控制终端的进程组
- shell& 结尾可以转后台执行
# 作业
- shell会为后台的每个进程赋予一个唯一的作业号
- jobs命令可以查看所有的后台作业
- control-Z可以挂起作业，他会向终端的前台进程组发送sigtstp信号
- fg 后台转前台 ，同时可以恢复挂起的作业，并转前台
- bg 可以恢复挂起的作业，并转后台